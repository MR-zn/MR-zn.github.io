<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VS2017连接ORACLE]]></title>
    <url>%2F2018%2F05%2F24%2F1%2F</url>
    <content type="text"><![CDATA[“折腾了一下oracle，写篇小心得。” Visual Studio 2017连接Oracle 12c数据库开发环境主机：Win10 + VS2017 + ODP.Net for VS2017 + Oracle 12c 配置ODP.Net首先下载 “Oracle Developer Tools for Visual Studio 2017” ，下载此文件需要注册Oracle社区账号并接受相关的协议，此文件提供了以下组件： Oracle Developer Tools for Visual Studio 12.1.0.2.4 Oracle Data Provider for .NET 4 12.1.0.2.0 Oracle Providers for ASP.NET 4 12.1.0.2.0 下载完成后，首先关闭VS，然后运行MSI安装程序进行安装，安装完成后会自动注册VS2017的相关插件，重新启动VS2017后将会看到Oracle的相关命令，比如SQL *PLUS支持等。同时添加数据库时也能看到相应的选项。 ODP.Net支持所有Oracle版本，因此下载时只需要注意VS的版本即可。 配置tnsnames.oraODP.Net默认使用安装目录下的tnsnames.ora，若安装目录在Program Files下，可能会遇到无权限等问题，此时使用管理员权限打开命令行，切换到对应目录并使用notepad编辑。 12345678&lt;数据源别名&gt; = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = &lt;主机名或IP&gt;)(PORT = &lt;端口号&gt;)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = &lt;数据库服务名&gt;) ) ) 添加数据库打开工具-连接到数据库，数据源修改为Oracle数据库下的ODP.NET,托管驱动程序，然后点击确定，打开添加连接窗口。 填写用户名，密码并选择数据源，然后测试连接，成功的话说明已经连通，点击确定即可。 连接数据库并使用连接数据库123456789101112131415161718private static string connectionString = &quot;Password=tiger;User ID=c##scott;Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=127.0.0.1)(PORT=1521)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=orcl)));&quot;;// private static string connectionStringpublic static DataTable ExecuteReader(String sql)&#123; DataTable dt = new DataTable(); DataSet ds = new DataSet(); OracleConnection connection = new OracleConnection(connectionString); connection.Open(); OracleCommand command = new OracleCommand(sql, connection); OracleDataAdapter sda = new OracleDataAdapter(command); sda.Fill(ds); dt = ds.Tables[0]; sda.Dispose(); ds.Dispose(); connection.Close(); return dt;&#125; 查询数据成功配置数据源之后，只需要向界面上拖动DataGridView，并进行相关配置，选择自己需要的表即可。 插入图片的正确姿势图片作为二进制数据无法直接拼凑出SQL命令，我们需要使用OracleCommand自带的Parameters功能。在SQL命令中用:photo来代表一个参量，然后使用 1sqlCom.Parameters.Add(&quot;photo&quot;, OracleDbType.Blob, imgData.Length) 来分别指定这个参量的类型和所占空间大小最后使用 1sqlCom.Parameters(0).Value = imgData 来指定这个参量的值。整个插入图片过程的代码如下： 123456789101112131415Dim conn As New OracleConnection(oradb)Dim imgData(0) As ByteDim ms As New System.IO.MemoryStreamPictureBox1.BackgroundImage.Save(ms, PictureBox1.BackgroundImage.RawFormat)ReDim imgData(ms.Length - 1)ms.Read(imgData, 0, ms.Length)ms.Close()conn.Open()Dim sql As String = &quot;insert into hero values&quot; &amp; &quot;(&quot; &amp; TextBox1.Text &amp; &quot;:photo&quot; &amp; &quot;)&quot;Dim sqlCom As New OracleCommandsqlCom.CommandText = sqlsqlCom.Connection = connsqlCom.Parameters.Add(&quot;photo&quot;, OracleDbType.Blob, imgData.Length)sqlCom.Parameters(0).Value = imgDatasqlCom.ExecuteNonQuery() 常见错误column not allowed here数据类型不符，检查对应项目数据类型是否正确。 missing comma命令格式不对，检查一下自己的SQL命令是否有错误，特别是在有字符串的时候，需要使用&quot;&quot;来代表一个字符串中的&quot;。 identifier is too long标识符过长（不得超过30字符），不是非常明白原因，不过我取消掉insert命令中指定位置的部分之后，这个错误消失了。 missing INTO keyword缺少into关键字（手滑打成了inte），检查一下自己的SQL命令是否有错误。 cannot insert NULL into (“SYSTEM”.“HERO”.“HEROCATEGORYID”)这些项都指定了非0值，故不能不赋值，为对应项目赋值即可。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Database</tag>
        <tag>ORACLE</tag>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git工具学习心得]]></title>
    <url>%2F2018%2F05%2F09%2F1%2F</url>
    <content type="text"><![CDATA[git工具学习的小心得 前言总的来说，在严格意义上来讲是我的第一篇博客吧。从开始折腾hexo，再到主题，然后是各种个性化的插件。那么到最后就碰到了如何将博客的源文件快速备份的问题。后来在网上找到了用git工具的分支技巧，很方便的可以推送备份。本篇文章根据我自己的学习经历，将重要的命令都罗列了出来，可以讲这个当作手册来看吧。 话不多说，正式开车！安装gitLinux安装Git1sudo apt-get install Git Mac OS X安装G 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Windows安装 官网直接下载安装程序，网速慢的同学请用国内镜像 设置信息安装完成后还需要设置用户名和邮箱12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 创建版本库接下来我们就要正式的使用git工具啦。 初始化仓库打开命令行，跳转至一个目录下，输入：1$ git init 即可将这个目录变为Git可以管理的仓库。如果细心的朋友应该可以发现，当前目录下多了一个.git目录，这个是Git用来管理版本库的，没事千万不要修改这里面的文件。如果你没有看到.git目录，那是因为它是默认隐藏的，用ls -ah即可看见。 暂存文件把当前的文件添加到仓库（暂存区）1$ git add filename 提交新版本将仓库（暂存区）中的文件提交到版本库中。1$ git commit -m 'operating introduction' 总结 git init git add filename git commit -m &quot;operating introduction&quot; 版本管理查看状态查看仓库当前的状态1$ git status 版本差异对比查看修改过后前后的不同处1$ git diff 版本回退 HEAD为当前指针所指向的版本，上一个版本为HEAD^，上上个版本就是HEAD^^，往上一个版本是HEAD~1001$ git reset --hard HEAD^ --hard参数有啥意义？后面会讲到。 查看操作日志12345678910111213$ git logcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 还原新版本将回退的版本还原到新版本如果上面的命令行还没关掉，你可以往上找。找到原来的commit id 1git reset --hard `commit id` 如果第二天起来想恢复到新版本，电脑早就关过了，找不到新版的commit id怎么办?不用怕，用git reflog命令即可。 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 总结在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 暂存区分支和HEAD的概念我们以后再讲。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。俗话说，实践出真知。 分支所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 而且一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。 总结暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 管理修改内容当你对同一文件进行add操作之后,再对他进行修改。随后你对它进行commit。你会发现，只有修改的第一次被提交了，而后面的修改都没有被提交。 为什么？ 那是因为，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- filename命令可以查看工作区和版本库里面最新版本的区别：1234567891011$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改当你发现你的文档中，有了错误的内容，你多输入了一句话。你需要修改他，两种方式。 撤销修改方法一 你可以删掉这一句话，手动恢复到上一个版本。 撤销修改方法二 使用git status查看一下 123456789$ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改: 1$ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库的状态一模一样。 一种是readme.txt已经添加到暂存区后，又作了修改。现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次的git commit或git add时的状态。 如果，我们不但写错了话，还git add到暂存区了怎么办？ 查看状态： 1234567$ git status# On branch master# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## modified: readme.txt# Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 还记得如何记得丢弃工作区的修改吗？ 12345$ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 整个世界清静了。 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件在Git中，删除文件也是一个修改操作。 一般情况下，我们通常直接在文件管理器中把没用的文件删除了，或者用rm命令删除了。 1$ rm test.txt 而且，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git status# On branch master# Changes not staged for commit:# (use "git add/rm &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## deleted: test.txt#no changes added to commit (use "git add" and/or "git commit -a") 现在，你有两个选择。 选择一你确实要从版本库中删除该文件，那就用命令git rm删除，并且git commit： 123456$ git rm test.txtrm 'test.txt'$ git commit -m "remove test.txt"[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中删除了。 选择二你删错了，但是版本库里还有呢，所以可以很轻松的把误删的文件恢复到最新的版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原。 小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心被误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 你好我的名字我的小名camara raw]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试页面]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
